<!DOCTYPE html><html lang=fr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=http://laveilleuse.io/styles/reset.css rel=stylesheet type=text/css><link href=http://laveilleuse.io/styles/style.css rel=stylesheet type=text/css><link href=http://laveilleuse.io/styles/darcula.css rel=stylesheet type=text/css><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel=icon href=favicon.ico type=image/x-icon><title>La Veilleuse</title></head><body><header class=global-header><h1 class=global-header-title><a href=http://laveilleuse.io/ >La Veilleuse</a></h1><div class=global-header-writers><article class=writer><img class=writer-picture src=http://laveilleuse.io/assets/common/picture-fberthelot.gif alt="Florent Berthelot"><h3 class=writer-name>Florent Berthelot</h3><p class=writer-biography>Développeur et formateur JavaScript (back et front), craftsman dans l'âme.</p></article><article class=writer><img class=writer-picture src=http://laveilleuse.io/assets/common/picture-jgrenat.jpg alt="Jordane Grenat"><h3 class=writer-name>Jordane Grenat <a href=https://twitter.com/JoGrenat class="writer-icon-link symbol">twitterbird</a></h3><p class=writer-biography>Développeur d'applications web depuis plusieurs années, je suis passionné par l'écosystème JavaScript sous toutes ses formes (frameworks front, Node.js, tooling, Elm, ...)</p></article></div></header><div class=container><section class=global-main><nav class=global-breadcrumb><a href=/ >Accueil</a> &gt; Web Audio API</nav><h2>Web Audio API</h2><main class=markdown><p>Dans cette course à l’armement du langage JavaScript, il ne faut pas oublier que des API sont aussi en train de se développer - ils en ont du boulot, les éditeurs de navigateurs ! Je vous laisse jeter un oeil à <a href=https://developer.mozilla.org/fr/docs/Web/API>la liste des API disponibles</a>. Ici, nous allons nous intéresser plus particulièrement à la partie des API; celle qui va enfin nous permettre de créer, modifier de la musique dans des pages web : La Web Audio API.</p><h2>Avant-propos</h2><p>L’API étant relativement bas niveau, je pense qu’il est bon de reprendre un peu les bases de ce qu’est le son.</p><p>Voici la définition du son de Wikipédia:</p><blockquote><p>Le son est une vibration mécanique d’un fluide, qui se propage sous forme d’ondes longitudinales grâce à la déformation élastique de ce fluide. Les êtres humains, comme beaucoup d’animaux, ressentent cette vibration grâce au sens de l’ouïe.</p></blockquote><p>Le son est donc une onde. C’est pour ça que les haut-parleurs font vibrer une membrane pour créer du son. Tout le monde se souvient de ses cours de seconde ? Ces cours nous disent qu’une onde est définie principalement par trois caractéristiques :</p><ul><li>L’amplitude : plus elle est élevée, plus le son sera perçu comme fort (On s’en sert pour régler le volume) ;</li><li>La période : c’est l’intervalle de temps minimal entre deux états vibratoires identiques ;</li><li>La fréquence : c’est l’inverse de la période (f = 1/t). Plus elle est élevée, plus le son est aigüe.</li></ul><p>Avec la Web Audio API nous allons donc faire en sorte d’assembler en rythme plusieurs sons pour produire de la musique.</p><h2>L’histoire de l’audio dans le web</h2><p>Avant de voir ce que l’API nous apporte, voyons ce que nous avions.</p><p>Les prémices du son dans des pages web date de 1995. À l’époque, trois types de balises étaient disponibles : <code>bgsound</code>, <code>embed</code> et <code>applet</code>. Autant dire que les possibilités était assez restreintes et qu’un développeur utilisant une de ces balises aujourd’hui ferait perdre des cheveux à n’importe quel UX designer.</p><p>En 1997, le flash est apparu avec un <em>player</em> et <em>Flash Media Server</em>, mais il n’existait toujours pas d’API native.</p><p>En 2008, c’est la révolution du HTML5 et l’intégration de la fameuse balise <code>&lt;audio&gt;</code>. Néanmoins, toujours pas moyen de produire directement du son.</p><p>Enfin, en 2010, le W3C définit la <em>Web Audio API</em>. À l’heure où j’écris ces lignes <a href=http://webaudio.github.io/web-audio-api/ >le document est en <em>Editor’s draft</em></a> mais <a href="http://caniuse.com/#search=web%20audio%20api">reste parfaitement utilisable sur tous les navigateurs, IE excepté</a>.</p><h2>OK, mais c’est quoi ?</h2><p>L’API nous permet donc enfin d’avoir un contrôle total sur le son. Comment ? Grâce à un routing modulaire, c’est-à-dire que nous allons appliquer des nœuds audio à une source audio pour obtenir un son transformé en sortie. Un nœud audio peut par exemple correspondre à un filtre de certaines fréquences ou à un amplificateur, etc.</p><p>Comme le disait Napoléon, “un bon croquis vaut mieux qu’un long discours” et je pense que c’est en songeant au fameux empereur que les développeurs de Firefox ont développé un outil des plus pratiques pour visualiser les nœuds et leurs propriétés.</p><p><img src=../../assets/articles/web-audio/ff-devtool.png alt="Image d'illustration des devtools de Firefox"></p><p>Dans cet exemple, nous apercevons donc différents nœuds et plus particulièrement les propriétés du nœud Analyser.</p><h2>Passons à la pratique !</h2><p>Voici le Hello world sonore :</p><pre><code class=language-javascript><span class=hljs-keyword>let</span> audioContext = <span class=hljs-keyword>new</span> AudioContext();
<span class=hljs-keyword>let</span> oscillator = audioContext.createOscillator();
oscillator.connect(audioContext.destination);
oscillator.start(audioContext.currentTime);
</code></pre><p>Après avoir créé un nouveau contexte audio, ce code crée un nœud de type oscillateur. Ce nœud, va nous permettre de créer du son, par défaut nous avons un oscillateur <a href=https://fr.wikipedia.org/wiki/La440>sinusoïdal de 440Hz</a>.</p><p>La troisième ligne connecte l’oscillateur à la destination du contexte audio. Concrètement, avant ces deux lignes, nous avions deux nœuds : l’oscillateur et la destination du contexte audio ; maintenant, la sortie de l’oscillateur est branchée à l’entrée du nœud de destination.</p><p>Enfin, la dernière ligne démarre l’oscillateur immédiatement.</p><h3>Attention avec le garbage collector</h3><p>Les fuites de mémoire sont très faciles à obtenir avec l’API. En effet, si vous perdez la référence vers un nœud, il est impossible pour vous d’aller récupérer ce nœud. Par exemple, si vous exécutez le code de l’exemple au-dessus dans une fonction onClick d’un bouton, vous aurez à chaque clic un nouveau oscillateur de créé. Firefox vous montrera alors ce genre de graphiques :</p><p><img src=../../assets/articles/web-audio/garbage_collector.png alt="Exemple d'un graphique Firefox avec des fuites de mémoire"></p><p>Vous pouvez d’ailleurs tester la fuite de mémoire à <a href=http://fberthelot.github.io/web-audio-api-examples/exemple1>cette adresse</a>.</p><h3>L’API est en avance sur le temps</h3><p>Vous aurez sans doute remarqué qu’il faut spécifier le temps actuel du contexte audio pour pouvoir démarrer l’oscillateur. Ce paramètre est envoyé pour la bonne raison que chaque nœud est en avance sur le temps du contexte audio. Pourquoi ? Tout simplement car un flux audio ne doit pas subir de ralentissement à cause des traitements JavaScript.</p><p>L’API met en place son propre système pour gérer le temps. Il faut donc faire très attention à ne pas utiliser des setInterval et setTimeout, il est important d’utiliser les événements et les Audio Params…</p><h3>… les Audio Params</h3><p>Nous avons vu que chaque nœud possède un ensemble de propriétés. Seulement, pour changer ces propriétés, nous devons faire attention au timing selon lequel nous allons les changer.</p><p>Pour cela, chaque nœud possède un ensemble de fonctions qui permettent de planifier le changement de chacun de leurs attributs. Par exemple pour augmenter progressivement la fréquence de notre précédent oscillateur, il faut faire :</p><pre><code class=language-javascript><span class=hljs-comment>// Va augmenter la fréquence de 440Hz à 456Hz linéairement pendant 10 secondes</span>
oscillator.frequency.linearRampToValueAtTime(<span class=hljs-number>456</span>, audioContext.currentTime + <span class=hljs-number>10</span>);
</code></pre><p>Il existe de nombreuses méthodes pour changer les attributs : <a href=https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setValueAtTime>setValueAtTime</a>, <a href=https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/linearRampToValueAtTime>linearRampToValueAtTime</a>, <a href=https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/exponentialRampToValueAtTime>exponentialRampToValueAtTime</a>, <a href=https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime>setTargetAtTime</a>, <a href=https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setValueCurveAtTime>setValueCurveAtTime</a> et <a href=https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/cancelScheduledValues>cancelScheduledValues</a>.</p><h3>Les différents types de nœuds</h3><p>Nous n’avons vu jusqu’ici que deux types de nœuds. Il en existe cependant plein d’autres :</p><ul><li><p><a href=https://developer.mozilla.org/fr/docs/Web/API/GainNode>GainNode</a> : ces nœuds servent à amplifier ou diminuer le signal. Concrètement, ils servent à contrôler le son ;</p></li><li><p><a href=http://webaudio.github.io/web-audio-api/#the-delaynode-interface>Delay</a>, ce type de nœud ralentit l’entrée avant de la propager à la sortie. Ils peuvent servir à créer un écho ;</p></li><li><p><a href=https://developer.mozilla.org/en-US/docs/Web/API/BiquadFilterNode>BiquadFilterNode</a> : type de nœud qui crée un filtre audio. Pour plus d’informations sur les filtres, <a href=https://fr.wikipedia.org/wiki/Filtre_%28audio%29#Filtres_passe-haut_et_passe-bas>vous pouvez aller voir sur Wikipédia</a> ;</p></li><li><p><a href=https://developer.mozilla.org/fr/docs/Web/API/AudioListener>PannerNode</a> : permet de spatialiser le son. Il est effectivement d’ores et déjà possible de faire un bon jeu de tir en JS avec un son 3D pour permettre aux joueurs de savoir d’où viennent les coups de feu !</p></li><li><p><a href=http://webaudio.github.io/web-audio-api/#linear-effects-using-convolution>Convolver</a> : généralement utilisés pour faire de la réverbération, ils servent à reproduire l’ambiance d’une pièce ;</p></li><li><p><a href=http://webaudio.github.io/web-audio-api/#the-channelsplitternode-interface>SplitterNode</a> : sert à séparer les différentes pistes d’une source audio, par exemple à partir d’une source stéréo on obtient en sortie deux sources : la droite et la gauche ;</p></li><li><p><a href=http://webaudio.github.io/web-audio-api/#the-channelmergernode-interface>MergerNode</a> : fait exactement le contraire du nœud précédent ;</p></li><li><p><a href=https://developer.mozilla.org/fr/docs/Web/API/WaveShaperNode>Waveshaper</a> : applique une distorsion aux signaux. Amis guitaristes, cet effet est pour vous !</p></li><li><p><a href=http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface>Compressor</a> : permet de réduire le volume des parties les plus fortes et d’augmenter celui de celles qui le sont moins ;</p></li><li><p><a href=https://developer.mozilla.org/fr/docs/Web/API/AnalyserNode>AnalyserNode</a> : nœud d’analyse il permet d’accéder en temps réel aux données du son. Il renvoie en sortie ce qu’il a exactement en entrée. Pratique pour faire un oscilloscope !</p></li><li><p><a href=https://developer.mozilla.org/fr/docs/Web/API/AudioBufferSourceNode>AudioBufferSourceNode</a> : nœud représentant une source audio (NB : type de nœud qui n’a aucune entrée, comme l’oscillateur). À utiliser uniquement pour les sons courts (inférieurs à une minute) ;</p></li><li><p><a href=https://developer.mozilla.org/fr/docs/Web/API/MediaElementAudioSourceNode>MediaElementAudioSourceNode</a> : comme le précédent il représente une source audio mais doit servir pour les sons longs. La source audio provient des balises <code>&lt;audio&gt;</code> et <code>&lt;video&gt;</code>.</p></li></ul><h2>Conclusion</h2><p>Bien que les spécifications W3C ne soient pas entièrement figées, la Web Audio API est d’ores et déjà très complète et implémentée dans les navigateurs récents comme sur les terminaux mobiles. Il est même dès à présent possible de faire des logiciels complexes de retouche audio en application web. <a href=../les-audio-worker>Dans le prochaine article, nous verrons ce que sont les web audio worker</a>.</p></main><div class=author><strong>Florent Berthelot</strong></div><div id=disqus_thread class=comments></div><script type=text/javascript>/*   CONFIGURATION VARIABLES   */
    	    var disqus_shortname = 'poneycase';

    	    (function() {
    	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    	        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    	    })();</script><noscript>Pour voir les commentaires, activez le JavaScript (on utilise Disqus).</noscript></section><footer class=global-footer><p class=global-footer-legal-info><a class=global-footer-legal-info-link href=https://creativecommons.org/licenses/by-nc-nd/3.0/ >La veilleuse est sous CC-BY-NC-ND</a></p></footer></div></body><script src=/lib/highlightjs/highlight.pack.min.js></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-87765875-1', 'auto');
  ga('send', 'pageview');</script></html>