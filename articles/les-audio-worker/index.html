<!DOCTYPE html><html lang=fr><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link href=http://laveilleuse.io/styles/reset.css rel=stylesheet type=text/css><link href=http://laveilleuse.io/styles/style.css rel=stylesheet type=text/css><link href=http://laveilleuse.io/styles/darcula.css rel=stylesheet type=text/css><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel=icon href=favicon.ico type=image/x-icon><title>La Veilleuse</title></head><body><header class=global-header><h1 class=global-header-title><a href=http://laveilleuse.io/ >La Veilleuse</a></h1><div class=global-header-writers><article class=writer><img class=writer-picture src=http://laveilleuse.io/assets/common/picture-fberthelot.gif alt="Florent Berthelot"><h3 class=writer-name>Florent Berthelot</h3><p class=writer-biography>Développeur et formateur JavaScript (back et front), craftsman dans l'âme.</p></article><article class=writer><img class=writer-picture src=http://laveilleuse.io/assets/common/picture-jgrenat.jpg alt="Jordane Grenat"><h3 class=writer-name>Jordane Grenat <a href=https://twitter.com/JoGrenat class="writer-icon-link symbol">twitterbird</a></h3><p class=writer-biography>Développeur d'applications web depuis plusieurs années, je suis passionné par l'écosystème JavaScript sous toutes ses formes (frameworks front, Node.js, tooling, Elm, ...)</p></article></div></header><div class=container><section class=global-main><nav class=global-breadcrumb><a href=/ >Accueil</a> &gt; Les Audio Worker</nav><h2>Les Audio Worker</h2><main class=markdown><p>Une des fonctionnalités les plus attendues par les développeurs qui font du web audio sont les Audio Workers. Nous allons voir ici ce qu’apportent ces nœuds, en quoi ils sont différents des autres et surtout pourquoi la communauté JS est autant excitée à ce sujet.</p><h2>Avant-propos</h2><p>Si vous ne savez pas ce qu’est la Web Audio API, vous pouvez regarder <a href=../web-audio-api>l’article précédent qui la décrit</a>.</p><p>Les Audio Workers sont toujours en cours de spécification, aucun navigateur ne les supporte actuellement. Cette article peut donc potentiellement décrire certaines fonctionnalités qui seront totalement différentes dans le futur. D’ailleurs, si vous avez des idées pour améliorer les spécifications n’hésitez pas à aller en discuter sur <a href=https://github.com/WebAudio/web-audio-api/issues>le fil github associé</a>.</p><h2>Le principe</h2><p>Les Audio Workers sont des nœuds personnalisés. C’est à dire qu’ici, nous avons le droit de modifier le signal bit par bit. Il est aussi possible de créer des paramètres spécifiques à ces nœuds. Tout comme les autres nœuds, nous pouvons utiliser toutes les fonctions disponibles pour les audio params comme <a href=http://webaudio.github.io/web-audio-api/#methods-3>linearRampToValueAtTime</a> par exemple.</p><p>De plus les Web Workers possèdent un système de messagerie. Il est en effet possible d’envoyer des messages à chaque nœud du même type. Le système de messagerie suggère que chaque instance partage un tronc commun : Il s’appelle l’<a href=http://webaudio.github.io/web-audio-api/#idl-def-AudioWorkerGlobalScope>AudioWorkerGlobalScope</a>.</p><h2>Comparaison avec ce que l’on a déjà</h2><h3>ScriptProcessorNode</h3><p>Actuellement, pour avoir un nœud qui fait des traitements spécifiques nous avions le nœud ScriptProcessorNode. Ce nœud, à l’instar de l’AnalyserNode, fonctionne avec un buffer. Tandis que le buffer de l’AnalyserNode est en lecture seule, celui du ScripProcessorNode est en écriture. Voici un exemple de code pour multiplier l’amplitude par 2 d’un signal :</p><pre><code class=language-javascript><span class=hljs-comment>// Création du ScriptProcessorNode avec un buffer de 4096, 1 entrée et 1 sortie</span>
<span class=hljs-keyword>var</span> ScriptProcessorNode = audioCtx.createScriptProcessor(<span class=hljs-number>4096</span>, <span class=hljs-number>1</span>, <span class=hljs-number>1</span>);

ScriptProcessorNode.onaudioprocess = <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>audioProcessingEvent</span>)</span>{
  <span class=hljs-keyword>var</span> inputBuffer = audioProcessingEvent.inputBuffer;
  <span class=hljs-keyword>var</span> outputBuffer = audioProcessingEvent.outputBuffer;
  <span class=hljs-comment>//Parcours de channel de la source audio (par exemple: gauche et droite en stéréo)</span>
  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i=<span class=hljs-number>0</span>; i &lt; outputBuffer.numberOfChannels; i++) {
    <span class=hljs-keyword>var</span> inputData = inputBuffer.getChannelData(i);
    <span class=hljs-keyword>var</span> outputData = outputBuffer.getChannelData(i);

    <span class=hljs-comment>//Parcours de l'ensemble du buffer</span>
    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> j=<span class=hljs-number>0</span>; j &lt; inputBuffer.length; j++) {
      outputData[j] = inputData[j] * <span class=hljs-number>2</span>; <span class=hljs-comment>//Multiplication de l'amplitude par 2</span>
    }
  }
}
</code></pre><p>Avec ce genre de nœud, on peut réellement faire tous les traitements que l’on souhaite sur le signal. Néanmoins, hormis la modularité que peut apporter le système des audio params, l’apport des Audio ne saute pas aux yeux.</p><h3>La même chose mais avec un Web Worker</h3><p>Le module des web workers permet d’inclure directement le nom du fichier contenant le code de notre nœud. Le code est donc séparé en deux fichiers :</p><p>Main.js</p><pre><code class=language-javascript><span class=hljs-comment>//Chargement du nœud dans l'audio contexte</span>
audioContext.createAudioWorker(<span class=hljs-string>"nodeFactory.js"</span>).then( <span class=hljs-function><span class=hljs-keyword>function</span>(<span class=hljs-params>factory</span>)
    </span>{
      <span class=hljs-comment>//Instanciation d'un nouveau nœud</span>
      <span class=hljs-keyword>var</span> node = factory.createNode();

      <span class=hljs-comment>//On peux utiliser les fonctions sur les audio params comme pour les autres nœuds</span>
      node.amplitudeMultiplier.setValueAtTime(<span class=hljs-number>0</span>, audioContext.currentTime);
      node.amplitudeMultiplier.linearRampToValueAtTime(<span class=hljs-number>10</span>, audioContext.currentTime + <span class=hljs-number>10</span>);

      node.connect(output);
      input.connect(node);
    }
  );
</code></pre><p>nodeFactory.js</p><pre><code class=language-javascript><span class=hljs-keyword>this</span>.addParameter( <span class=hljs-string>"amplitudeMultiplier"</span>, <span class=hljs-number>8</span> );
onaudioprocess= <span class=hljs-function><span class=hljs-keyword>function</span> (<span class=hljs-params>e</span>) </span>{
  <span class=hljs-comment>// De même, parcours des channels</span>
  <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> i=<span class=hljs-number>0</span>; i&lt; e.inputs[<span class=hljs-number>0</span>].length; i++) {
    <span class=hljs-keyword>var</span> inputBuffer = e.inputs[<span class=hljs-number>0</span>][i];
    <span class=hljs-keyword>var</span> outputBuffer = e.outputs[<span class=hljs-number>0</span>][i];
    <span class=hljs-keyword>var</span> bufferLength = inputBuffer.length;
    <span class=hljs-comment>//Parcours du buffer</span>
    <span class=hljs-keyword>for</span> (<span class=hljs-keyword>var</span> j=<span class=hljs-number>0</span>; j&lt;bufferLength; j++) {
      outputBuffer[j] = inputBuffer[j] * e.parameters.amplitudeMultiplier;
    }
  }
};
</code></pre><p>A première vue, il n’y a pas de grandes différences avec le ScriptProcessorNode, sauf qu’il y a une couche d’abstraction supplémentaire ici. Cela rend le code plus joli lors de la création de nouveau type de nœuds, mais rien de plus.</p><h2>Une histoire de file d’exécution</h2><p>Comme nous l’avons vu dans l’article précédent, la web audio api n’est pas exécutée dans le même file d’exécution que celui du rendu et même que celui de l’exécution du JS en général. Or, le code à l’intérieur du ScriptProcessorNode est exécuté dans la file d’exécution principale et cela soulève de gros problèmes de performance. En effet, ce code sera impacté par les performances de Rendering, d’exécution du reste du JS et autre code de la page. Cela signifie qu’un bug sonore peut survenir si en même temps on demande au navigateur de nous afficher un tableau de 1000 lignes.</p><p>Les codes à l’intérieur des Web Audio Worker quant à eux s’exécutent dans la file d’exécution réservée à l’audio. La possibilité de bug audio à cause d’un rendering gourmand est alors nulle !</p><h3>Asynchronisme incompatible avec l’Audio</h3><p>Quand un ScriptProcessorNode cherche à redéfinir sa sortie, la modification se fait de manière asynchrone. Comme le nœud ne peut pas simplement attendre, le nœud insère de la latence. En effet, le nœud attend une certaine volumétrie de données (la taille du buffer) et ensuite fait les appels asynchrones entre les différentes files d’exécution. Ensuite le nœud ajoute encore de la latence pour avoir le temps de traiter les données.</p><p>Pour illustrer le propos, <a href=https://plus.google.com/+ChrisWilson/posts>le développeur de Google Chris Wilson</a> explique que ce type de nœud inclus une latence d’environ 23ms pour un buffer de 512 bits et plus de 50ms pour un buffer de 1024 bits (qui est la valeur pas défaut).</p><p>Avec les Web Audio Worker, le code est directement exécuté dans la file d’exécution de l’audio. Il n’y a pas d’appel transverse, donc l’appel aux fonctions peut se faire de façon synchrone. La seule latence sera le temps d’exécution de notre code.</p><h2>Conclusion</h2><p>Les Web Audio Workers apporteront beaucoup plus de flexibilité dans notre manière d’écrire du code avec la Web Audio API et apporteront surtout de bien meilleures performances. Le seul regret que l’on peut avoir est que le code dans les scriptProcessorNode ne soit pas exécuté dans la bonne file d’exécution. Cela aurait résolu pas mal de problèmes de performance. À cause de ça, le scriptProcessorNode sera amené à disparaître. Il est d’ailleurs déjà <em>“deprecated”</em> dans la spécification, même s’il est vrai qu’il est difficile de faire une spécification parfaite dès le départ.</p></main><div class=author><strong>Florent Berthelot</strong></div><div id=disqus_thread class=comments></div><script type=text/javascript>/*   CONFIGURATION VARIABLES   */
    	    var disqus_shortname = 'poneycase';

    	    (function() {
    	        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    	        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
    	        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    	    })();</script><noscript>Pour voir les commentaires, activez le JavaScript (on utilise Disqus).</noscript></section><footer class=global-footer><p class=global-footer-legal-info><a class=global-footer-legal-info-link href=https://creativecommons.org/licenses/by-nc-nd/3.0/ >La veilleuse est sous CC-BY-NC-ND</a></p></footer></div></body><script src=/lib/highlightjs/highlight.pack.min.js></script><script>hljs.initHighlightingOnLoad();</script><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-87765875-1', 'auto');
  ga('send', 'pageview');</script></html>